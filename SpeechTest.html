<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <title>浏览器内置语音转文字示例</title>
    <!-- 引入Bootstrap CSS -->
    <link href="./css/bootstrap.min.css" rel="stylesheet">
    <!-- 引入Alpine.js -->
    <script src="./js/alpine.min.js" defer></script>
    <!-- 引入Bootstrap JS -->
    <script src="./js/bootstrap.min.js"></script>
    <script src="./config.js"></script>

    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 40px 0;
            background-color: #f0f2f5;
        }

        .btn-custom {
            width: 150px;
        }

        pre {
            background: #ffffff;
            padding: 15px;
            border-radius: 6px;
            text-align: left;
            white-space: pre-wrap;
            word-wrap: break-word;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            max-height: 300px;
            overflow-y: auto;
            margin: 20px 0;
        }

        /* 增强按钮的视觉效果 */
        .start-btn:hover {
            background-color: #45a049;
        }

        .stop-btn:hover {
            background-color: #e53935;
        }

        /* 状态指示圆点样式 */
        .indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .listening {
            background-color: #4caf50;
        }

        .not-listening {
            background-color: #f44336;
        }

        .transcribing {
            background-color: #2196f3;
        }

        .not-transcribing {
            background-color: #9e9e9e;
        }

        .locking {
            background-color: #ff9800;
            /* 橙色表示锁定 */
        }

        .not-locking {
            background-color: #9e9e9e;
            /* 灰色表示未锁定 */
        }

        /* Spinner样式 */
        .spinner-border {
            width: 20px;
            height: 20px;
        }

        /* 锁定状态显示样式 */
        .lock-status {
            display: flex;
            align-items: center;
            margin-top: 10px;
        }
    </style>
</head>
<script>
    // 检测 config.js 是否加载完成
    if (typeof SRB_Config === 'undefined') {
        alert('config.js 没有成功配置, 请复制文件夹中的 config.sample.js 并重命名为 config.js, 然后修改其中的内容以配置 API 密钥. 否则AI评价部分无法使用!');
    } else {
        console.log(SRB_Config);
    }
</script>

<body x-data="speechRecognition()" x-init="init()">
    <div class="container">

        <!-- 转录控制按钮 -->
        <div class="d-flex justify-content-center mb-4">
            <button @click="toggleTranscription"
                :class="isTranscribing ? 'btn btn-danger btn-custom' : 'btn btn-success btn-custom'" class="me-3">
                <span x-text="isTranscribing ? '停止转录' : '开始转录'"></span>
            </button>
        </div>

        <!-- 状态指示 -->
        <div class="row justify-content-center mb-4">
            <div class="col-md-6">
                <div class="card p-3">
                    <!-- 麦克风状态 -->
                    <div class="d-flex align-items-center">
                        <span :class="isRecognizing ? 'indicator listening' : 'indicator not-listening'"></span>
                        <strong x-text="isRecognizing ? '麦克风正在监听' : '麦克风未监听'"></strong>
                        <template x-if="isStarting">
                            <div class="spinner-border text-primary ms-3" role="status">
                                <span class="visually-hidden">Loading...</span>
                            </div>
                        </template>
                    </div>
                    <!-- 转录状态 -->
                    <div class="d-flex align-items-center">
                        <span :class="isTranscribing ? 'indicator transcribing' : 'indicator not-transcribing'"></span>
                        <strong x-text="isTranscribing ? '语音转文字中' : '语音转文字已停止'"></strong>
                    </div>
                    <!-- 锁定状态显示 -->
                    <div class="d-flex align-items-center">
                        <span :class="isLocked ? 'indicator locking' : 'indicator not-locking'"></span>
                        <strong x-text="isLocked ? '转录已锁定' : '转录未锁定'"></strong>
                    </div>
                </div>
            </div>
        </div>

        <!-- 实时显示内容 -->
        <div class="row justify-content-center">
            <div class="col-md-8">
                <div class="card mb-4">
                    <div class="card-header bg-primary text-white d-flex justify-content-between align-items-center">
                        <span>实时显示内容</span>
                        <button @click="summarizeContent" :disabled="isSummarizing || displayContent.trim() === ''"
                            class="btn btn-info btn-sm">
                            总结
                        </button>
                    </div>
                    <div class="card-body">
                        <pre x-text="displayContent"></pre>
                    </div>
                </div>
            </div>
        </div>

        <!-- 总结内容展示 -->
        <div class="row justify-content-center">
            <div class="col-md-8">
                <div class="card">
                    <div class="card-header bg-success text-white">
                        内容总结
                    </div>
                    <div class="card-body">
                        <pre x-text="summaryContent"></pre>
                    </div>
                </div>
            </div>
        </div>

        <!-- 格式化的 JSON 数据 -->
        <div class="row justify-content-center mt-4">
            <div class="col-md-8">
                <div class="card">
                    <div class="card-header bg-secondary text-white d-flex justify-content-between align-items-center">
                        <span>格式化的 JSON 数据</span>
                        <button @click="toggleJsonCollapse" class="btn btn-light btn-sm">
                            <span x-text="isJsonCollapsed ? '展开' : '收起'"></span>
                        </button>
                    </div>
                    <div :class="{'collapse': isJsonCollapsed}" class="card-body">
                        <pre x-text="formattedSpeechContent()"></pre>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        function speechRecognition() {
            return {
                config() {
                    if (typeof SRB_Config === 'undefined') {
                        console.log("config未定义");
                        return {}
                    }

                    return SRB_Config;
                },
                // 状态标志
                isRecognizing: false, // 麦克风监听状态
                isTranscribing: false, // 语音转文字处理状态
                isProcessing: false, // 正在处理转录内容
                isChecking: false, // 正在检查内容
                isSummarizing: false, // 正在总结内容
                recognition: null, // SpeechRecognition实例
                displayContent: "", // 实时显示内容
                summaryContent: "", // 总结内容
                completedSpeechContent: { paragraphs: [] }, // 已完成的语音内容
                currentSpeechTranscript: "", // 当前临时句子
                totalSentenceCount: 0, // 已完成句子总数
                restartAttempts: 0, // 重启尝试次数
                maxRestartAttempts: 10, // 最大重启次数
                restartDelay: 500, // 重启延迟（毫秒）
                isStarting: false, // 标志：识别正在启动
                isJsonCollapsed: true, // 格式化JSON是否折叠
                isLocked: false, // 锁定状态
                isRestarting: false, // 防止多次重启

                // 初始化函数
                init() {
                    // 初始化 Web Speech API
                    window.SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition || null;

                    if (!window.SpeechRecognition) {
                        this.showAlert('您的浏览器不支持语音识别。请使用最新版本的 Chrome 或 Edge。', 'danger');
                        return;
                    }

                    this.recognition = new window.SpeechRecognition();
                    this.recognition.lang = 'zh-CN';
                    this.recognition.interimResults = true;
                    this.recognition.continuous = true;

                    // 识别开始事件
                    this.recognition.onstart = () => {
                        console.log('语音识别已启动。');
                        this.isRecognizing = true;
                        this.isStarting = false; // 识别已成功启动
                        this.restartAttempts = 0; // 重启次数重置
                        this.isRestarting = false; // 重启标志重置
                    };

                    // 识别错误事件
                    this.recognition.onerror = (event) => {
                        console.error('语音识别错误:', event.error);
                        // 根据错误类型采取不同策略
                        if (event.error === 'not-allowed' || event.error === 'service-not-allowed') {
                            this.showAlert('语音识别权限被拒绝。请允许访问麦克风。', 'danger');
                            this.isRecognizing = false;
                            this.isTranscribing = false;
                            this.isLocked = false; // 解除锁定
                        } else {
                            this.showAlert(`语音识别错误: ${event.error}`, 'warning');
                            this.isRecognizing = false;
                            if (!this.isLocked) {
                                this.isTranscribing = false;
                            }
                            this.handleRecognitionEnd();
                        }
                        this.isStarting = false; // 识别启动失败
                    };

                    // 识别结束事件
                    this.recognition.onend = () => {
                        console.log('语音识别已结束。');
                        this.isRecognizing = false;
                        if (!this.isLocked) {
                            this.isTranscribing = false;
                        }
                        this.handleRecognitionEnd();
                        this.isStarting = false; // 确保标志重置
                    };

                    // 识别结果事件
                    this.recognition.onresult = (event) => {
                        if (!this.isTranscribing) {
                            // 如果未开启转录，忽略结果
                            return;
                        }

                        this.isProcessing = true;

                        for (let i = event.resultIndex; i < event.results.length; i++) {
                            const result = event.results[i];
                            const transcript = result[0].transcript.trim();
                            const isFinal = result.isFinal;

                            if (isFinal) {
                                this.pushCompletedSpeechContent(transcript);
                                this.currentSpeechTranscript = "";
                            } else {
                                // 更新当前临时句子
                                this.currentSpeechTranscript = transcript;
                            }
                        }

                        // 更新 displayContent
                        this.flushDisplaycontent();
                        this.isProcessing = false;
                    };

                    // 不自动启动录音，等待用户操作
                },
                async getAIResponse(prompt) {
                    if (!this.config().aiApiKey) {
                        throw new Error("API key is not set.");
                    }
                    const requestBody = {
                        model: this.config().model,
                        messages: [
                            { role: "system", content: prompt },
                        ],
                        stream: false,
                        temperature: 1.1
                    };

                    try {
                        const response = await fetch(this.config().aiUrl, {
                            method: "POST",
                            headers: {
                                "Content-Type": "application/json",
                                "Authorization": `Bearer ${this.config().aiApiKey}`
                            },
                            body: JSON.stringify(requestBody)
                            // Removed 'signal' as it was undefined. Add AbortController if needed.
                        });

                        if (!response.ok) {
                            throw new Error(`API request failed with status ${response.status}`);
                        }

                        const data = await response.json();
                        return data.choices[0].message.content;
                    } catch (error) {
                        console.error('AI响应错误:', error);
                        throw error;
                    }
                },
                async checkCompletedSpeechParagraph(paragraphIndex) {
                    const paragraph = this.completedSpeechContent.paragraphs[paragraphIndex];
                    if (!paragraph || paragraph.isChecked) {
                        return;
                    }

                    this.isChecking = true;
                    this.showAlert(`正在检查第 ${paragraphIndex + 1} 段落...`, 'info');
                    console.log(`正在检查第 ${paragraphIndex + 1} 段落...`);

                    // 拼接段落的所有句子
                    const promptContent = paragraph.sentences.map(s => s.finalTranscript).join(' ');

                    // 编写优化的 prompt
                    const prompt = `
接下来我会给你一段语音转文字的内容,其中包含了很多的错别字和语音转文字错误的内容, 我需要你对其进行校对。
请检查下面内容的语法和拼写错误，并提供修改后的文本。仅返回修改后的文本，不要包含任何其他内容。
下面的内容的主题是:一名CS2(反恐精英2)教学博主正在观看他粉丝的demo,时不时提出玩法上的建议。
-----
${promptContent}
-----
现在开始校对,正确使用CS2中的专业名词修正内容,你返回给我的内容我会直接显示在ui中,不要给我任何的与校对结果无关的内容。
`;

                    try {
                        const aiResponse = await this.getAIResponse(prompt);
                        paragraph.checkedTranscript = aiResponse.trim();
                        paragraph.isChecked = true;
                        this.showAlert(`第 ${paragraphIndex + 1} 段落检查完成。`, 'success');
                        console.log(`第 ${paragraphIndex + 1} 段落检查完成。`);
                    } catch (error) {
                        console.error(`检查第 ${paragraphIndex + 1} 段落失败:`, error);
                        this.showAlert(`检查第 ${paragraphIndex + 1} 段落失败: ${error.message}`, 'danger');
                    }

                    // 更新显示内容
                    this.flushDisplaycontent();
                    this.isChecking = false;
                },
                // 将完成的转录内容添加到completedSpeechContent
                async pushCompletedSpeechContent(finalTranscript) {
                    // 计算段落索引，每10个句子为一个段落
                    const paragraphIndex = Math.floor(this.totalSentenceCount / 10);
                    // 计算句子索引，0-9
                    const sentenceIndex = this.totalSentenceCount % 10;

                    // 检查是否需要添加新的段落到 completedSpeechContent
                    if (!this.completedSpeechContent.paragraphs[paragraphIndex]) {
                        // 使用直接赋值确保段落在正确的位置
                        this.completedSpeechContent.paragraphs[paragraphIndex] = {
                            sentences: [],
                            isChecked: false,
                            checkedTranscript: ""
                        };
                    }

                    console.log(this.completedSpeechContent);

                    const currentCompletedParagraph = this.completedSpeechContent.paragraphs[paragraphIndex];

                    console.log(currentCompletedParagraph);

                    // 确保 sentences 数组有足够的长度（10个句子）
                    while (currentCompletedParagraph.sentences.length < 10) {
                        currentCompletedParagraph.sentences.push({});
                    }

                    // 使用 splice 确保 Alpine.js 能检测到数组变化
                    currentCompletedParagraph.sentences.splice(sentenceIndex, 1, {
                        finalTranscript: finalTranscript
                    });

                    this.totalSentenceCount += 1;

                    // 如果当前句子是段落的最后一句，则自动检查该段落
                    if (sentenceIndex === 9) {
                        this.checkCompletedSpeechParagraph(paragraphIndex);
                    }
                },

                // 处理识别结束事件
                handleRecognitionEnd() {
                    // 仅在转录状态下尝试重启
                    if (this.isTranscribing) {
                        // 检查麦克风是否正在监听
                        if (this.isRecognizing) {
                            console.log('麦克风正在监听，不需要重启语音识别。');
                            return;
                        }

                        if (this.isRestarting) {
                            // 如果已经在重启过程中，避免重复尝试
                            console.log('已经在尝试重启语音识别，等待当前重启完成。');
                            return;
                        }

                        if (this.restartAttempts < this.maxRestartAttempts) {
                            this.restartAttempts++;
                            this.isRestarting = true;
                            console.log(`尝试重启语音识别 (${this.restartAttempts}/${this.maxRestartAttempts}) in ${this.restartDelay / 1000}秒...`);
                            this.showAlert(`尝试重启语音识别 (${this.restartAttempts}/${this.maxRestartAttempts}) in ${this.restartDelay / 1000}秒...`, 'warning');
                            setTimeout(() => {
                                // 在重启前再次检查麦克风状态
                                if (!this.isRecognizing && !this.isStarting) {
                                    this.startRecognition();
                                } else {
                                    console.log('麦克风正在监听，取消重启语音识别。');
                                    this.showAlert('麦克风正在监听，取消重启语音识别。', 'info');
                                }
                                this.isRestarting = false;
                            }, this.restartDelay);
                        } else {
                            console.warn('达到最大重启次数，语音识别停止。');
                            this.showAlert('语音识别已停止。请手动重新启动。', 'warning');
                            this.isTranscribing = false; // 解除锁定
                            this.isLocked = false;
                        }
                    } else {
                        // 非转录状态下，如果需要处理其他逻辑，可以在这里添加
                        console.log('语音识别已结束，但未处于转录状态。');
                    }
                },

                // 切换转录状态
                toggleTranscription() {
                    if (!this.isTranscribing) {
                        // 开始转录
                        this.isTranscribing = true;
                        this.isLocked = true; // 自动锁定
                        console.log('开始转录语音...');
                        this.showAlert('语音转文字已开始，并已锁定。', 'success');
                        // 更新显示状态
                        this.flushDisplaycontent();
                        // 启动语音识别
                        this.startRecognition();
                    } else {
                        // 停止转录
                        this.isTranscribing = false;
                        this.isLocked = false; // 解除锁定
                        console.log('停止转录语音...');
                        this.showAlert('语音转文字已停止，并已解除锁定。', 'info');
                        // 更新显示状态
                        if (this.currentSpeechTranscript) {
                            this.pushCompletedSpeechContent(this.currentSpeechTranscript);
                            this.currentSpeechTranscript = "";
                            this.flushDisplaycontent();
                        }
                        // 停止语音识别
                        this.stopRecognition();
                    }
                },

                // 启动语音识别
                startRecognition() {
                    if (this.recognition && !this.isRecognizing && !this.isStarting) {
                        try {
                            this.isStarting = true; // 标记识别正在启动
                            this.recognition.start(); // 开始录音会话
                            console.log('启动语音识别...');
                        } catch (error) {
                            this.isStarting = false; // 识别启动失败
                            console.error('启动语音识别失败:', error);
                            this.showAlert('启动语音识别失败，请重试。', 'danger');
                        }
                    }
                },

                // 停止语音识别
                stopRecognition() {
                    if (this.recognition && this.isRecognizing) {
                        try {
                            this.isRecognizing = false; // 更新状态为未监听
                            this.recognition.abort(); // 终止当前的录音会话
                            console.log('停止语音识别。');
                        } catch (error) {
                            console.error('停止语音识别失败:', error);
                            this.showAlert('停止语音识别失败，请重试。', 'danger');
                        }
                    }
                },

                // 更新显示内容
                flushDisplaycontent() {
                    let content = "";
                    this.completedSpeechContent.paragraphs.forEach(paragraph => {
                        if (paragraph.isChecked && paragraph.checkedTranscript) {
                            content += paragraph.checkedTranscript + "\n";
                        } else {
                            paragraph.sentences.forEach(sentence => {
                                if (sentence.finalTranscript) {
                                    content += sentence.finalTranscript + " ";
                                }
                            });
                            content += "\n";
                        }
                    });
                    // 添加当前临时句子
                    if (this.isTranscribing && this.currentSpeechTranscript) {
                        content += this.currentSpeechTranscript + " ";
                    }
                    this.displayContent = content.trim();
                },

                // 简单格式化JSON内容
                formattedSpeechContent() {
                    try {
                        return JSON.stringify(this.completedSpeechContent, null, 2);
                    } catch (error) {
                        console.error('格式化 JSON 失败:', error);
                        return '格式化 JSON 失败';
                    }
                },

                // 切换 JSON 数据显示与隐藏
                toggleJsonCollapse() {
                    this.isJsonCollapsed = !this.isJsonCollapsed;
                },

                // 总结内容
                async summarizeContent() {
                    if (this.isSummarizing) {
                        this.showAlert('当前正在总结内容，请稍后再试。', 'warning');
                        return;
                    }

                    if (this.displayContent.trim() === '') {
                        this.showAlert('没有内容可供总结。', 'warning');
                        return;
                    }

                    this.isSummarizing = true;
                    this.showAlert('开始总结内容...', 'info');
                    console.log('开始总结内容...');

                    // 编写总结的 prompt
                    const prompt = `
下面的内容是来自一位教学主播观察玩家游戏录像,为玩家提出游戏意见的语音转文字内容,我需要你去帮忙总结内容。
请总结以下内容的要点，确保覆盖所有主要信息。仅返回总结内容，不要包含任何其他内容。

内容:
${this.displayContent}

需要你尽可能多的总结,总结越多条越细致越好,这样更能帮助到玩家
`;

                    try {
                        const aiResponse = await this.getAIResponse(prompt);
                        this.summaryContent = aiResponse.trim();
                        this.showAlert('内容总结完成。', 'success');
                        console.log('内容总结完成。');
                    } catch (error) {
                        console.error('内容总结失败:', error);
                        this.showAlert(`内容总结失败: ${error.message}`, 'danger');
                    }

                    this.isSummarizing = false;
                },

                // 显示Bootstrap Alert
                showAlert(message, type) {
                    // 创建一个临时Alert元素
                    const alertContainer = document.createElement('div');
                    alertContainer.className = `alert alert-${type} alert-dismissible fade show position-fixed top-0 end-0 m-3`;
                    alertContainer.setAttribute('role', 'alert');
                    alertContainer.innerHTML = `
                        ${message}
                        <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
                    `;
                    document.body.appendChild(alertContainer);

                    // 自动移除Alert after 5 seconds
                    setTimeout(() => {
                        const alert = bootstrap.Alert.getOrCreateInstance(alertContainer);
                        alert.close();
                    }, 5000);
                }
            };
        }
    </script>
</body>

</html>